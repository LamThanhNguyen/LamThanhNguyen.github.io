<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>I. Concurrency and Parallelism In Golang And Python | Liam Blogs</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="description" content="Deep Dive Into Concurrency and Parallelism in Golang and Python">
    <meta name="generator" content="Hugo 0.147.9">
    
    
    
      <meta name="robots" content="index, follow">
    
    

    
<link rel="stylesheet" href="/ananke/css/main.min.8d048772ae72ab11245a0e296d1f2a36d3e3dd376c6c867394d6cc659c68fc37.css" >




    


    
      
<link rel="shortcut icon" href="/images/favicon_logo.webp" type="image/x-icon" />


    

    

    
      <link rel="canonical" href="https://lamthanhnguyen.github.io/programming-language/concurrency-and-parallelism-in-golang-and-python/">
    

    <meta property="og:url" content="https://lamthanhnguyen.github.io/programming-language/concurrency-and-parallelism-in-golang-and-python/">
  <meta property="og:site_name" content="Liam Blogs">
  <meta property="og:title" content="I. Concurrency and Parallelism In Golang And Python">
  <meta property="og:description" content="Deep Dive Into Concurrency and Parallelism in Golang and Python">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="programming-language">
    <meta property="article:tag" content="Python">
    <meta property="article:tag" content="Golang">
    <meta property="article:tag" content="Concurrency">
    <meta property="article:tag" content="Parallelism">

  <meta itemprop="name" content="I. Concurrency and Parallelism In Golang And Python">
  <meta itemprop="description" content="Deep Dive Into Concurrency and Parallelism in Golang and Python">
  <meta itemprop="wordCount" content="1319">
  <meta itemprop="keywords" content="Python,Golang,Concurrency,Parallelism">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="I. Concurrency and Parallelism In Golang And Python">
  <meta name="twitter:description" content="Deep Dive Into Concurrency and Parallelism in Golang and Python">

      
    
	
  </head><body class="ma0 avenir bg-near-white production">

    
   
  

  
  
  
  <header class="cover bg-center" style="background-image: url('https://lamthanhnguyen.github.io/images/concurrency-parallelism-golang-python.png');">
    <div class="bg-black-60">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l center items-center justify-between">
    <a href="/" class="f3 fw2 hover-white white-90 dib no-underline">
      
        Liam Blogs
      
    </a>
    <div class="flex-l items-center">
      

      
        <ul class="pl0 mr3">
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white white-90 no-underline" href="/about/" title="About page">
              About
            </a>
          </li>
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white white-90 no-underline" href="/aws/" title="AWS page">
              AWS
            </a>
          </li>
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white white-90 no-underline" href="/database/" title="Database page">
              Database
            </a>
          </li>
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white white-90 no-underline" href="/kubernetes/" title="Kubernetes page">
              Kubernetes
            </a>
          </li>
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white white-90 no-underline" href="/programming-language/" title="Programming Language page">
              Programming Language
            </a>
          </li>
          
        </ul>
      
      <div class="ananke-socials"><a href="http://linkedin.com/in/lam-thanh-nguyen-abcd6789" target="_blank" rel="noopener"
        class="ananke-social-link link-transition linkedin link dib z-999 pt3 pt0-l mr1"
        title="follow on LinkedIn - Opens in a new window"
        aria-label="follow on LinkedIn - Opens in a new window">
      <span class="icon">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.6.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc. --><path d="M416 32H31.9C14.3 32 0 46.5 0 64.3v383.4C0 465.5 14.3 480 31.9 480H416c17.6 0 32-14.5 32-32.3V64.3c0-17.8-14.4-32.3-32-32.3zM135.4 416H69V202.2h66.5V416zm-33.2-243c-21.3 0-38.5-17.3-38.5-38.5S80.9 96 102.2 96c21.2 0 38.5 17.3 38.5 38.5 0 21.3-17.2 38.5-38.5 38.5zm282.1 243h-66.4V312c0-24.8-.5-56.7-34.5-56.7-34.6 0-39.9 27-39.9 54.9V416h-66.4V202.2h63.7v29.2h.9c8.9-16.8 30.6-34.5 62.9-34.5 67.2 0 79.7 44.3 79.7 101.9V416z"/></svg>
            
          </span></a></div>

    </div>
  </div>
</nav>

      <div class="tc-l pv6 ph3 ph4-ns">
        
          <div class="f2 f1-l fw2 white-90 mb0 lh-title">I. Concurrency and Parallelism In Golang And Python</div>
          
            <div class="fw1 f5 f3-l white-80 measure-wide-l center lh-copy mt3 mb4">
              Deep Dive Into Concurrency and Parallelism in Golang and Python
            </div>
          
        
      </div>
    </div>
  </header>



    <main class="pb7" role="main">
      
  
  
  <article class="flex-l mw8 center ph3 flex-wrap justify-between">
    <header class="mt4 w-100">
      <aside class="instapaper_ignoref b helvetica tracked ttu">
          
        Programming Language
      </aside><div id="sharing" class="mt3 ananke-socials"><a href="https://www.linkedin.com/shareArticle?&amp;mini=true&amp;source=https%3A%2F%2Flamthanhnguyen.github.io%2Fprogramming-language%2Fconcurrency-and-parallelism-in-golang-and-python%2F&amp;summary=Table&#43;of&#43;Contents&#43;1.&#43;Introduction&#43;Why&#43;concurrency&#43;and&#43;parallelism&#43;matter&#43;Key&#43;differences&#43;between&#43;concurrency&#43;and&#43;parallelism&#43;2.&#43;Concurrency&#43;in&#43;Golang&#43;Goroutines&#43;Channels&#43;Example&#43;code&#43;3.&#43;Concurrency&#43;in&#43;Python&#43;Threads&#43;Asyncio%3A&#43;Concurrency&#43;for&#43;IO-bound&#43;Work&#43;Example&#43;code&#43;4.&#43;Parallelism&#43;in&#43;Golang&#43;Go&#43;Scheduler%3A&#43;The&#43;G-M-P&#43;Model&#43;Example&#43;code&#43;5.&#43;Parallelism&#43;in&#43;Python&#43;The&#43;GIL&#43;and&#43;Its&#43;Impact&#43;Multiprocessing&#43;for&#43;Real&#43;Parallelism&#43;Example&#43;code&#43;6.&#43;Conclustion&#43;1.&#43;Introduction&#43;-&#43;Why&#43;concurrency&#43;and&#43;parallelism&#43;matter%3A&#43;Modern&#43;software&#43;isn%E2%80%99t&#43;just&#43;about&#43;doing&#43;one&#43;thing&#43;at&#43;a&#43;time.&#43;From&#43;high-traffic&#43;web&#43;servers&#43;and&#43;real-time&#43;analytics%2C&#43;to&#43;background&#43;processing&#43;and&#43;automation%2C&#43;today%E2%80%99s&#43;applications&#43;often&#43;need&#43;to&#43;handle&#43;multiple&#43;tasks&#43;%E2%80%9Cat&#43;once.%E2%80%9D&#43;Whether&#43;it%E2%80%99s&#43;serving&#43;thousands&#43;of&#43;user&#43;requests%2C&#43;processing&#43;large&#43;datasets%2C&#43;or&#43;running&#43;background&#43;jobs%2C&#43;your&#43;program%E2%80%99s&#43;ability&#43;to&#43;efficiently&#43;juggle&#43;several&#43;operations&#43;can&#43;be&#43;the&#43;difference&#43;between&#43;fast%2C&#43;scalable&#43;software&#43;and&#43;a&#43;sluggish%2C&#43;unresponsive&#43;system.%0A&amp;title=I.&#43;Concurrency&#43;and&#43;Parallelism&#43;In&#43;Golang&#43;And&#43;Python&amp;url=https%3A%2F%2Flamthanhnguyen.github.io%2Fprogramming-language%2Fconcurrency-and-parallelism-in-golang-and-python%2F"
        class="ananke-social-link linkedin no-underline"
        title="Share on LinkedIn" aria-label="Share on LinkedIn"
        target="_blank" rel="nofollow noopener noreferrer">
        <span class="icon">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.6.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc. --><path d="M416 32H31.9C14.3 32 0 46.5 0 64.3v383.4C0 465.5 14.3 480 31.9 480H416c17.6 0 32-14.5 32-32.3V64.3c0-17.8-14.4-32.3-32-32.3zM135.4 416H69V202.2h66.5V416zm-33.2-243c-21.3 0-38.5-17.3-38.5-38.5S80.9 96 102.2 96c21.2 0 38.5 17.3 38.5 38.5 0 21.3-17.2 38.5-38.5 38.5zm282.1 243h-66.4V312c0-24.8-.5-56.7-34.5-56.7-34.6 0-39.9 27-39.9 54.9V416h-66.4V202.2h63.7v29.2h.9c8.9-16.8 30.6-34.5 62.9-34.5 67.2 0 79.7 44.3 79.7 101.9V416z"/></svg>
                
              </span></a></div>
<h1 class="f1 athelas mt3 mb1">I. Concurrency and Parallelism In Golang And Python</h1>
      
      
      

      
      
    </header>
    <div class="nested-copy-line-height lh-copy serif f4 nested-links mid-gray pr4-l w-two-thirds-l"><h2 id="table-of-contents">Table of Contents</h2>
<ul>
<li><a href="#1-introduction">1. Introduction</a>
<ul>
<li><a href="#--why-concurrency-and-parallelism-matter">Why concurrency and parallelism matter</a></li>
<li><a href="#--key-differences-between-concurrency-and-parallelism">Key differences between concurrency and parallelism</a></li>
</ul>
</li>
<li><a href="#2-concurrency-in-golang">2. Concurrency in Golang</a>
<ul>
<li><a href="#--goroutines">Goroutines</a></li>
<li><a href="#--channels">Channels</a></li>
<li><a href="#--example-code">Example code</a></li>
</ul>
</li>
<li><a href="#3-concurrency-in-python">3. Concurrency in Python</a>
<ul>
<li><a href="#--threads">Threads</a></li>
<li><a href="#--asyncio-concurrency-for-io-bound-work">Asyncio: Concurrency for IO-bound Work</a></li>
<li><a href="#--example-code-1">Example code</a></li>
</ul>
</li>
<li><a href="#4-parallelism-in-golang">4. Parallelism in Golang</a>
<ul>
<li><a href="#go-scheduler-the-g-m-p-model">Go Scheduler: The G-M-P Model</a></li>
<li><a href="#--example-code-2">Example code</a></li>
</ul>
</li>
<li><a href="#5-parallelism-in-python">5. Parallelism in Python</a>
<ul>
<li><a href="#--the-gil-and-its-impact">The GIL and Its Impact</a></li>
<li><a href="#--multiprocessing-for-real-parallelism">Multiprocessing for Real Parallelism</a></li>
<li><a href="#--example-code-3">Example code</a></li>
</ul>
</li>
<li><a href="#6-conclustion">6. Conclustion</a></li>
</ul>
<h1 id="1-introduction">1. Introduction</h1>
<h2 id="--why-concurrency-and-parallelism-matter">- Why concurrency and parallelism matter:</h2>
<p>Modern software isn’t just about doing one thing at a time. From high-traffic web servers and real-time analytics, to background processing and automation, today’s applications often need to handle multiple tasks “at once.” Whether it’s serving thousands of user requests, processing large datasets, or running background jobs, your program’s ability to efficiently juggle several operations can be the difference between fast, scalable software and a sluggish, unresponsive system.</p>
<p>That’s where <strong>concurrency</strong> and <strong>parallelism</strong> come in. Mastering these concepts can lead to:</p>
<ul>
<li><strong>Faster applications</strong> that take full advantage of modern multi-core CPUs.</li>
<li><strong>Scalability</strong>, allowing your services to handle more work without major rewrites.</li>
<li><strong>Cleaner codebases</strong>, with logic separated into manageable, independent pieces.</li>
</ul>
<p>But while they’re often mentioned together, concurrency and parallelism are <strong>not the same thing</strong>.</p>
<h2 id="--key-differences-between-concurrency-and-parallelism">- Key differences between concurrency and parallelism:</h2>
<p><strong>Concurrency</strong> is about dealing with lots of things at once—structuring your program so it can manage many tasks that may need to happen together.</p>
<p><strong>Parallelism</strong> is about doing lots of things at exactly the same time.</p>
<p><strong>The Chef and the Kitchen</strong></p>
<p>Imagine a single chef in a kitchen:</p>
<ul>
<li>The chef has several dishes to prepare.</li>
<li>They might chop vegetables for one dish, then switch to boiling pasta for another, then check the oven for a third dish, switching back and forth as needed.</li>
</ul>
<p>This chef is working <strong>concurrently</strong>: handling multiple tasks at once by rapidly switching between them, but only ever doing one thing at any given moment.</p>
<p>Now imagine a <em>team of chefs</em>, each in the same kitchen:</p>
<ul>
<li>Each chef can work on a different dish at the same time: one is chopping, another is boiling, another is baking.</li>
</ul>
<p>This is <strong>parallelism</strong>: multiple tasks truly happening at the same time, speeding up the meal preparation.</p>
<h1 id="2-concurrency-in-golang">2. Concurrency in Golang</h1>
<h2 id="--goroutines">- Goroutines:</h2>
<p>At the <em>heart of Go’s</em> approach to concurrency is the <strong>goroutine</strong>. Goroutines are lightweight, independently executing functions managed by the Go runtime (not the OS), making them much more efficient than traditional threads.</p>
<ul>
<li><strong>Lightweight</strong>: Starting a goroutine costs very little memory (as little as a 2 KB stack, which grows as needed). You can easily run thousands—even millions—of goroutines in a single Go program.</li>
<li><strong>Managed by Go Runtime</strong>: The Go scheduler multiplexes goroutines onto a pool of operating system threads, so you don’t have to manage threads directly.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">go</span> <span style="color:#a6e22e">myFunction</span>()
</span></span></code></pre></div><h2 id="--channels">- Channels:</h2>
<p>Goroutines are powerful, but they’re even more useful when they work together. <strong>Channels</strong> are Go’s elegant way to <strong>communicate and synchronize between goroutines</strong>.</p>
<ul>
<li>Think of a channel as a pipe: one goroutine can send values in, and another can receive them out.
Channels are typed (chan int, chan string, etc.), ensuring safe and predictable communication.
They can also be buffered (holding a set number of values) or unbuffered (synchronizing sender and receiver).</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">ch</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>)    <span style="color:#75715e">// Create a channel of int</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">ch</span> <span style="color:#f92672">&lt;-</span> <span style="color:#ae81ff">100</span>            <span style="color:#75715e">// Send value into channel</span>
</span></span><span style="display:flex;"><span>}()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">val</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">ch</span>             <span style="color:#75715e">// Receive value from channel</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">val</span>)        <span style="color:#75715e">// Output: 100</span>
</span></span></code></pre></div><h3 id="unbuffered-channels-makechan-t">Unbuffered Channels (make(chan T))</h3>
<ul>
<li>An unbuffered channel has <em>no capacity</em>—it can hold zero elements.</li>
<li><strong>Send blocks until receive</strong>: When you send (ch &lt;- val), the operation blocks until another goroutine is ready to receive (&lt;-ch) from the channel.</li>
<li><strong>Receive blocks until send</strong>: When you receive from the channel, it blocks until a goroutine sends a value.</li>
<li><strong>Use case</strong>: Great for synchronization: ensures the sender and receiver rendezvous (&ldquo;handshake&rdquo;).</li>
</ul>
<h3 id="buffered-channels-makechan-t-capacity">Buffered Channels (make(chan T, capacity))</h3>
<ul>
<li>A buffered channel <em>has capacity</em> N—it can hold up to N elements.</li>
<li><strong>Send blocks only if buffer is full</strong>: The sender (ch &lt;- val) only blocks when the buffer is full.</li>
<li><strong>Receive blocks only if buffer is empty</strong>: The receiver (&lt;-ch) blocks only when the buffer is empty.</li>
<li><strong>Use case</strong>: Good for decoupling producer and consumer speeds; allows some &ldquo;slack&rdquo; between them.</li>
</ul>
<p>Channels make it easy to coordinate work, fan out tasks, and collect results—without explicit locks or mutexes.</p>
<h2 id="--example-code">- Example code:</h2>
<p>You can see the code in the repository: <a href="https://github.com/LamThanhNguyen/Concurrency-Parallelism-in-Python-Golang">https://github.com/LamThanhNguyen/Concurrency-Parallelism-in-Python-Golang</a></p>
<h1 id="3-concurrency-in-python">3. Concurrency in Python</h1>
<h2 id="--threads">- Threads</h2>
<p>Threads in Python allow you to write code that appears concurrent, with multiple threads doing work <em>‘at the same time’</em>.</p>
<ul>
<li>However, the Global Interpreter Lock (GIL) means that only one thread can execute Python bytecode at a time (even on multi-core CPUs).</li>
<li>This limits true parallelism for CPU-bound code, but threads are still useful for IO-bound tasks (like network calls or file operations).</li>
</ul>
<h2 id="--asyncio-concurrency-for-io-bound-work">- Asyncio: Concurrency for IO-bound Work</h2>
<p><strong>Asyncio</strong> provides native support for asynchronous programming using async/await.
This is ideal for managing thousands of simultaneous IO-bound operations, like HTTP requests or database calls, all in a single OS thread.</p>
<ul>
<li>Each fetch data coroutine runs asynchronously—when it hits await, control returns to the event loop, which can switch to another task.</li>
<li>Ideal for network requests, APIs, or anything with lots of waiting.</li>
<li><strong>Not for CPU-bound work</strong>: Asyncio can’t run CPU-intensive code in parallel; it’s designed for IO-bound concurrency.</li>
</ul>
<h2 id="--example-code-1">- Example code:</h2>
<p>You can see the code in the repository: <a href="https://github.com/LamThanhNguyen/Concurrency-Parallelism-in-Python-Golang">https://github.com/LamThanhNguyen/Concurrency-Parallelism-in-Python-Golang</a></p>
<h1 id="4-parallelism-in-golang">4. Parallelism in Golang</h1>
<p>The environment variable <strong>GOMAXPROCS</strong> (or <strong>runtime.GOMAXPROCS(n)</strong> in code) sets the <strong>maximum number of CPU cores</strong> Go will use for running goroutines in parallel.</p>
<h2 id="go-scheduler-the-g-m-p-model">Go Scheduler: The G-M-P Model</h2>
<p>Go’s runtime uses a unique, high-performance scheduler, based on three concepts:</p>
<ul>
<li><strong>G</strong> — Goroutine: the actual lightweight thread</li>
<li><strong>M</strong> — Machine: a wrapper for an OS thread</li>
<li><strong>P</strong> — Processor: a resource that schedules goroutines onto threads.
Only as many goroutines can run in parallel as there are Ps (set by GOMAXPROCS).</li>
</ul>
<p><strong>Work Stealing:</strong>
Each processor (P) has its own run queue of goroutines. If a P runs out of work, it “steals” goroutines from others, balancing the workload efficiently.</p>
<p>[Goroutine] -&gt; [Processor] -&gt; [Machine/OS thread] -&gt; [CPU core]</p>
<ul>
<li>Many Gs are scheduled onto Ps.</li>
<li>Ps are tied to Ms (OS threads).</li>
<li>Ms are executed on real CPU cores.</li>
</ul>
<p>This lets Go utilize all available CPU cores for compute-heavy workloads with minimal code changes.</p>
<h2 id="--example-code-2">- Example code:</h2>
<p>You can see the code in the repository: <a href="https://github.com/LamThanhNguyen/Concurrency-Parallelism-in-Python-Golang">https://github.com/LamThanhNguyen/Concurrency-Parallelism-in-Python-Golang</a></p>
<h1 id="5-parallelism-in-python">5. Parallelism in Python</h1>
<h2 id="--the-gil-and-its-impact">- The GIL and Its Impact</h2>
<p>Python’s most popular implementation (CPython) uses a mechanism called the Global Interpreter Lock (GIL). The GIL ensures that only one thread executes Python bytecode at a time—even on a multi-core machine.</p>
<ul>
<li>For CPU-bound code (math, data crunching, etc.), Python threads cannot run in true parallel. They take turns, so you get concurrency but not parallelism.</li>
<li>For IO-bound code (network, disk, waiting), threads can be useful, because while one thread is waiting, another can work.</li>
</ul>
<h2 id="--multiprocessing-for-real-parallelism">- Multiprocessing for Real Parallelism</h2>
<p>The multiprocessing module sidesteps the GIL by launching multiple processes, each with its own Python interpreter and memory space.</p>
<ul>
<li>Each process runs fully in parallel—one per CPU core—so you get true parallelism for heavy computations.</li>
<li>Each process is heavier than a thread, as it has its own interpreter and memory space.</li>
</ul>
<h2 id="--example-code-3">- Example code:</h2>
<p>You can see the code in the repository: <a href="https://github.com/LamThanhNguyen/Concurrency-Parallelism-in-Python-Golang">https://github.com/LamThanhNguyen/Concurrency-Parallelism-in-Python-Golang</a></p>
<h1 id="6-conclustion">6. Conclustion</h1>
<table>
  <thead>
      <tr>
          <th style="text-align: center">Feature</th>
          <th style="text-align: center">Go Goroutines</th>
          <th style="text-align: center">Python Threading</th>
          <th style="text-align: center">Python Asyncio</th>
          <th style="text-align: center">Python Multiprocessing</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: center">Lightweight</td>
          <td style="text-align: center">✔️ (very)</td>
          <td style="text-align: center">❌ (heavy)</td>
          <td style="text-align: center">✔️ (light)</td>
          <td style="text-align: center">❌ (heavy)</td>
      </tr>
      <tr>
          <td style="text-align: center">True parallelism</td>
          <td style="text-align: center">✔️ (with GOMAXPROCS)</td>
          <td style="text-align: center">❌ (GIL)</td>
          <td style="text-align: center">❌ (single-threaded)</td>
          <td style="text-align: center">✔️ (separate process)</td>
      </tr>
      <tr>
          <td style="text-align: center">Best for</td>
          <td style="text-align: center">IO &amp; CPU-bound</td>
          <td style="text-align: center">IO-bound</td>
          <td style="text-align: center">IO-bound</td>
          <td style="text-align: center">CPU-bound</td>
      </tr>
  </tbody>
</table>
<p><strong>Concurrency</strong> and <strong>parallelism</strong> are key skills for any backend or systems engineer. <strong>Golang’s goroutines and channels</strong> make concurrent and parallel programming both easy and robust, while <strong>Python</strong> offers a range of tools for IO- and CPU-bound work—if you know which to use, and when. Try out the examples, check out the full code in my repository, and explore which model fits your next project best!</p>
<ul class="pa0">
  
   <li class="list di">
     <a href="/tags/python/" class="link f5 grow br-pill ba ph3 pv2 mb2 dib black sans-serif no-underline">Python</a>
   </li>
  
   <li class="list di">
     <a href="/tags/golang/" class="link f5 grow br-pill ba ph3 pv2 mb2 dib black sans-serif no-underline">Golang</a>
   </li>
  
   <li class="list di">
     <a href="/tags/concurrency/" class="link f5 grow br-pill ba ph3 pv2 mb2 dib black sans-serif no-underline">Concurrency</a>
   </li>
  
   <li class="list di">
     <a href="/tags/parallelism/" class="link f5 grow br-pill ba ph3 pv2 mb2 dib black sans-serif no-underline">Parallelism</a>
   </li>
  
</ul>
<div class="mt6 instapaper_ignoref">
      
      
      </div>
    </div>

    <aside class="w-30-l mt6-l">




</aside>

  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white white-70 dn dib-ns pv2 ph3 no-underline" href="https://lamthanhnguyen.github.io/" >
    &copy;  Liam Blogs 2025 
  </a>
    <div><div class="ananke-socials"><a href="http://linkedin.com/in/lam-thanh-nguyen-abcd6789" target="_blank" rel="noopener"
        class="ananke-social-link link-transition linkedin link dib z-999 pt3 pt0-l mr1"
        title="follow on LinkedIn - Opens in a new window"
        aria-label="follow on LinkedIn - Opens in a new window">
      <span class="icon">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.6.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc. --><path d="M416 32H31.9C14.3 32 0 46.5 0 64.3v383.4C0 465.5 14.3 480 31.9 480H416c17.6 0 32-14.5 32-32.3V64.3c0-17.8-14.4-32.3-32-32.3zM135.4 416H69V202.2h66.5V416zm-33.2-243c-21.3 0-38.5-17.3-38.5-38.5S80.9 96 102.2 96c21.2 0 38.5 17.3 38.5 38.5 0 21.3-17.2 38.5-38.5 38.5zm282.1 243h-66.4V312c0-24.8-.5-56.7-34.5-56.7-34.6 0-39.9 27-39.9 54.9V416h-66.4V202.2h63.7v29.2h.9c8.9-16.8 30.6-34.5 62.9-34.5 67.2 0 79.7 44.3 79.7 101.9V416z"/></svg>
            
          </span></a></div>
</div>
  </div>
</footer>

  </body>
</html>
